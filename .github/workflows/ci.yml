name: Z13 Installation Script CI

on:
  push:
    branches: [ main, stable, development ]
  pull_request:
    branches: [ main, stable, development ]
  schedule:
    # Run tests daily at 2 AM UTC
    - cron: '0 2 * * *'

jobs:
  test:
    runs-on: ubuntu-latest
    if: github.ref != 'refs/heads/main'
    strategy:
      matrix:
        test-type: [unit, integration, performance, security]
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up test environment
      run: |
        sudo apt-get update
        sudo apt-get install -y bc shellcheck python3
        
    - name: Make test scripts executable
      run: |
        chmod +x Tests/*.sh
        chmod +x pcmr.sh
        chmod +x Modules/*.sh
        
    - name: Run ShellCheck
      run: |
        find . -name "*.sh" -type f | xargs shellcheck -e SC1091,SC2034,SC2086
        
    - name: Run ${{ matrix.test-type }} tests
      run: |
        cd Tests
        ./run_tests.sh ${{ matrix.test-type }} --junit-xml --html-report
        
    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: test-results-${{ matrix.test-type }}
        path: |
          Tests/results/
          Tests/coverage/
          
    - name: Publish test results
      uses: dorny/test-reporter@v1
      if: matrix.test-type == 'unit' && always()
      with:
        name: Unit Tests
        path: Tests/results/junit.xml
        reporter: java-junit

  security-scan:
    runs-on: ubuntu-latest
    if: github.ref != 'refs/heads/main'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Bandit security scan
      run: |
        # Install bandit for Python security scanning
        pip install bandit
        # Scan any Python scripts (if any)
        find . -name "*.py" -type f | xargs bandit -r || true
        
    - name: Run shell script security scan
      run: |
        # Check for common security issues in shell scripts
        find . -name "*.sh" -type f -print0 | xargs -0 grep -E -l 'eval|exec|\$\(|`' > security_issues.txt || true
        if [ -s security_issues.txt ]; then
          echo "Potential security issues found in:"
          cat security_issues.txt
          echo "Please review these files for security vulnerabilities"
        fi
        
    - name: Check file permissions
      run: |
        # Check for files with overly permissive permissions
        find . -type f -perm /o+w | tee world_writable.txt
        if [ -s world_writable.txt ]; then
          echo "World-writable files found:"
          cat world_writable.txt
          exit 1
        fi

  code-quality:
    runs-on: ubuntu-latest
    if: github.ref != 'refs/heads/main'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y shellcheck shfmt pwsh
        
    - name: Check shell script formatting
      run: |
        # Check if scripts are properly formatted
        find . -name "*.sh" -type f | xargs shfmt -d -i 4 -ci
        
    - name: Run comprehensive ShellCheck
      run: |
        # Run ShellCheck with comprehensive checks
        find . -name "*.sh" -type f | xargs shellcheck -x -e SC1091

    - name: Lint PowerShell scripts (PSScriptAnalyzer)
      run: |
        pwsh -NoProfile -Command "Install-Module PSScriptAnalyzer -Scope CurrentUser -Force; Invoke-ScriptAnalyzer -Path . -Recurse -EnableExit"
        
    - name: Check for TODO/FIXME comments
      run: |
        # Find TODO and FIXME comments for tracking
        grep -Er "TODO|FIXME|XXX|HACK" --include="*.sh" --include="*.md" . || true
        
    - name: Validate JSON configuration files
      run: |
        # Validate all JSON configuration files
        find Configs -name "*.json" -type f | xargs -I {} sh -c 'echo "Validating {}"; python3 -m json.tool {} > /dev/null'

  integration-test:
    runs-on: ubuntu-latest
    if: github.ref != 'refs/heads/main'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up mock Arch environment
      run: |
        # Create mock directories that the script expects
        sudo mkdir -p /usr/share/zoneinfo/America
        sudo mkdir -p /sys/firmware/efi
        sudo mkdir -p /sys/class/power_supply
        echo "mock timezone data" | sudo tee /usr/share/zoneinfo/America/New_York > /dev/null
        
    - name: Test configuration loading
      run: |
        # Test that all configuration files can be loaded
        for config in Configs/*.json; do
          echo "Testing configuration: $config"
          python3 -m json.tool "$config" > /dev/null
          echo "‚úì $config is valid JSON"
        done
        
    - name: Test module loading
      run: |
        # Test that all modules can be sourced without errors
        for module in Modules/*.sh; do
          echo "Testing module: $module"
          bash -n "$module"
          echo "‚úì $module has valid syntax"
        done
        
    - name: Run integration tests
      run: |
        cd Tests
        chmod +x run_tests.sh
        ./run_tests.sh integration --verbose

  documentation:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Check documentation links
      run: |
        # Install markdown link checker
        npm install -g markdown-link-check
        
        # Check all markdown files for broken links (recursive)
        find . -name "*.md" -print0 | xargs -0 -I {} bash -c 'echo Checking {}; markdown-link-check "{}" --config .github/workflows/link-check-config.json'
        
    - name: Generate documentation
      run: |
        # Generate documentation from comments in scripts
        find . -name "*.sh" -type f -exec grep -l "^#.*Description:" {} \; | while read -r file; do
          echo "=== Documentation for $file ==="
          grep "^#" "$file" | head -20
          echo ""
        done > GENERATED_DOCS.md
        
    - name: Upload documentation
      uses: actions/upload-artifact@v3
      with:
        name: generated-documentation
        path: GENERATED_DOCS.md

  release-check:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/stable'
    needs: [test, security-scan, code-quality, integration-test]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Check version consistency
      run: |
        # Extract version from main script
        SCRIPT_VERSION=$(grep "^# Version:" pcmr.sh | head -1 | awk '{print $3}')
        echo "Script version: $SCRIPT_VERSION"
        
        # Check if version is consistent across files
        if grep -q "Version: $SCRIPT_VERSION" README.md; then
          echo "‚úì Version is consistent in README.md"
        else
          echo "‚ö† Version mismatch in README.md"
        fi
        
    - name: Create release artifacts
      run: |
        # Create release package
        mkdir -p release
        cp -r Modules Configs Tests Docs release/
        cp pcmr.sh README.md release/
        
        # Create checksums
        cd release
        find . -type f -exec sha256sum {} \; > SHA256SUMS
        
    - name: Upload release artifacts
      uses: actions/upload-artifact@v3
      with:
        name: release-package
        path: release/

  notify:
    runs-on: ubuntu-latest
    if: always()
    needs: [test, security-scan, code-quality, integration-test]
    steps:
    - name: Notify on success
      if: needs.test.result == 'success' && needs.security-scan.result == 'success' && needs.code-quality.result == 'success' && needs.integration-test.result == 'success'
      run: |
        echo "üéâ All checks passed! The Z13 installation script is ready for deployment."
        
    - name: Notify on failure
      if: needs.test.result == 'failure' || needs.security-scan.result == 'failure' || needs.code-quality.result == 'failure' || needs.integration-test.result == 'failure'
      run: |
        echo "‚ùå Some checks failed. Please review the test results and fix any issues."
        exit 1
